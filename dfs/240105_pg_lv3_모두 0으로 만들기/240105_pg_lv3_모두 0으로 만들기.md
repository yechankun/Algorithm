
## 문제 링크

[코딩테스트 연습 - 모두 0으로 만들기](https://school.programmers.co.kr/learn/courses/30/lessons/76503)

## 문제 풀이

1. 이 문제는 DFS와 BFS 방식으로 풀 수 있다.
2. 이번에 푼 방식은 DFS로 BFS보다 조금 더 간단하고 효율적이다.
3. 문제 유형을 파악하기 어렵지만 그래프의 정점이 30만 정도면 DFS와 BFS를 생각해봐야 한다.
4. 기본적으로 DFS, BFS는 O(N)의 복잡도이기 때문임.

## 풀이 코드

```python
from collections import defaultdict
import sys
sys.setrecursionlimit(10**7)

def solution(a, edges):
    if sum(a) != 0:
        return -1
    
    # 그래프 만들기
    graph = defaultdict(list)
    # 간선 정보 입력
    for fr, to in edges:
        graph[fr].append(to)
        graph[to].append(fr)
    
    visited = [0] * len(a)
    answer = 0
    def dfs(curr):
        nonlocal answer
        visited[curr] = True
        for child in graph[curr]:
            if visited[child]:
                continue
            a[curr] += dfs(child)

        a[curr], val = 0, a[curr]
        answer += abs(val)
        
        return val
    dfs(0)
    
    return answer
```