## 문제 링크

https://www.acmicpc.net/problem/1463

## 풀이 접근법

- 다이나믹 프로그래밍으로 푼다.
- 바텀업 방식, 탑 다운 방식으로 풀 수 있는데 탑 다운이 좀 더 빠르고 메모리를 적게 쓴다.

## 풀이 코드

```python
# 바텀 업
N = int(input())

# dp를 이용해서 정수 1부터 연산 횟수를 계산한다.
# 바텀 업 방식임.
dp = [0] * (N+1)
for i in range(2, N+1):
    dp[i] = dp[i-1] + 1
    if i % 3 == 0:
        dp[i] = dp[i//3] + 1
    elif i % 2 == 0:
        dp[i] = min(dp[i], dp[i//2] + 1)
print(dp[N]) # 532ms
```

```python
# 탑 다운
import sys
sys.setrecursionlimit(10**8)
N = int(input())
dp = {1:0, 2:1, 3:1}

def topdown(n):
    if n in dp:
        return dp[n]
    if n % 3 == 0 and n % 2 == 0:
        dp[n] = min(topdown(n//3)+1, topdown(n//2) + 1)
    elif n % 3 == 0:
        dp[n] = min(topdown(n-1) + 1, topdown(n//3) + 1)
    elif n % 2 == 0:
        dp[n] = min(topdown(n-1) + 1, topdown(n//2) + 1)
    else:
        dp[n] = topdown(n-1) + 1

    return dp[n] # 44ms
```
