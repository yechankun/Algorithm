## 문제 링크

[코드트리 | 코딩테스트 준비를 위한 알고리즘 정석](https://www.codetree.ai/training-field/frequent-problems/problems/rabit-and-race/description)

## 문제 풀이

1. 조금 생각이 필요한 우선순위 큐 문제
2. drc를 이용해서 곱셈과 while문을 이용해 보드 안에 들어올 때까지 if문을 돌릴려고 했으나 시간초과
3. 알려져 있는 가장 좋은 접근법으로는 2*(N-1) - d % (2*(N-1)), d % (2*(N-1))를 상하 벡터로 이용하고
4. 그 후 x + d를 (N-1)로 나눈 몫과 나머지를 구해 몫을 2로 나눈 나머지가 1이면 N - 1 - 앞서 구한 나머지로 계산하는 방법이 있는데
5. 이는 실전에서 이용할 수 없는 접근법을 알아내는 것만으로 엄청나게 오래걸리는 접근법이라 무시했다.
6. 결국 2중 if문을 사용한 하드코딩으로 풀어서 풀리길래 while문을 다시 써보자 그냥 M을 N이라 쓰는 오타가 있어서 틀린 것.
7. 시간은 굉장히 넉넉하게 849ms가 나왔는데 수행시간으로 봤을 때 상위 5% 내의 풀이다.
8.  오타를 잘 보는 습관을 들여야겠다.

## 풀이 코드

```python
import sys
sys.stdin = open('priority queue/230810_ct_g1_토끼와 경주/1.in', 'r')
input = sys.stdin.readline

from heapq import heappush, heappop, heapify

def solution():


    # 경주 시작 준비
    Q = int(input())

    _, N, M, P, *pids = list(map(int, input().split()))
    rabbits = list(zip(pids[::2], pids[1::2]))
    move_power = {}
    scores = {}
    for i in range(0, len(pids), 2):
        move_power[pids[i]] = pids[i+1]
        scores[pids[i]] = 0

    positions = [(0, 2, 1, 1, pid) for pid, d in rabbits]
    heapify(positions)
    add = 0


    positions = [(0, 2, 1, 1, pid) for pid, d in rabbits]
    heapify(positions)
    add = 0
    N2 = N*2-2
    M2 = M*2-2

    drc = ((-1, 0), (1, 0), (0, -1), (0, 1))
    # 경주 진행
    def start(K, S):
        nonlocal add
        winner = []
        for _ in range(K):
            cnt, s, r, c, pid = heappop(positions)
            nxt = []
            for dr, dc in drc:
                nr, nc = r + (dr*move_power[pid])%N2, c + (dc*move_power[pid])%M2

                # 이동
                while not (0 < nr <= N and 0 < nc <= M):
                    if nr < 1:
                        nr = -nr + 2
                    elif nr > N:
                        nr = N - (nr - N)
                    elif nc < 1:
                        nc = -nc + 2
                    elif nc > M:
                        nc = M - (nc - M)
                else:
                    heappush(nxt, (-(nr+nc), -nr, -nc ))           
            s, nr, nc = nxt[0]
            winner.append((-s, -nr, -nc, pid))

            # 나머지 토끼 점수 계산
            add += -s
            scores[pid] += s # 점수 빼버리기
            heappush(positions, (cnt+1, -s, -nr, -nc, pid)) # 최소값
        _, _, _, pid = max(winner)
        scores[pid] += S
        return
    
    # 이동 거리 변경
    def edit(pid_t, L):
        move_power[pid_t] *= L
        return

    commands = {200: start, 300: edit}

    # 명령 정보 받기
    for _ in range(Q-1):
        inputs = list(map(int, input().split()))
        if(inputs[0] == 400):
            break

        cmd, p1, p2 = inputs
        commands[cmd](p1, p2)

    return max(scores.values()) + add

print(solution())
```