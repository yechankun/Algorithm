
## 문제 링크

[코딩테스트 연습 - 모두 0으로 만들기](https://school.programmers.co.kr/learn/courses/30/lessons/76503)

## 문제 풀이

1. 이 문제는 DFS와 BFS 방식으로 풀 수 있다.
2. 내가 푼 방식은 BFS와 가깝다.
3. DFS가 조금 더 효율적인 결과가 나올 것으로 보인다.
4. 문제 유형을 파악하기 어렵지만 그래프의 정점이 30만 정도면 DFS와 BFS를 생각해봐야 한다.
5. 기본적으로 DFS, BFS는 O(N)의 복잡도이기 때문임.

## 풀이 코드

```python
from collections import defaultdict

def solution(a, edges):
    answer = -2
    if sum(a) != 0:
        return -1
    
    # 그래프 만들기
    graph = defaultdict(list)
    # 간선 정보 입력
    for fr, to in edges:
        graph[fr].append(to)
        graph[to].append(fr)
        
    
    # 리프노드 찾기
    leaf = []
    for node in graph:
        if len(graph[node]) == 1:
            leaf.append(node)
    
    # 핵심부분 - 아쉽게 시간 내엔 틀린 부분
    conn_counts = [len(graph[i]) for i in range(len(a))]
    # leaf가 빌 때까지 반복
    visited = set()
    count = 0
    while leaf:
        nxt = []
        for l in leaf:
            if l in visited:
                continue
            visited.add(l)
            if a[l] == 0:
                continue
            for node in graph[l]:
                if node in visited:
                    continue
                a[node] += a[l]
                count += abs(a[l])
                a[l] = 0          
                conn_counts[node] -= 1
                if conn_counts[node] == 1:
                    nxt.append(node)
        leaf = nxt
    return count
```