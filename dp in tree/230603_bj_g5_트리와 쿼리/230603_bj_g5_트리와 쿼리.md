## 문제 링크

[15681번: 트리와 쿼리](https://www.acmicpc.net/problem/15681)

## 문제 풀이

- dfs와 dp를 결합해 풀 수 있는 문제다.
- dfs에서 전위, 중위, 후위 순회 관계 없이 풀 수 있는 문제다.
- 풀이에서는 전위 순회를 사용했다.

1. 트리의 탐색 dfs를 활용한다.
2. dp에 노드를 탐색하며 dp[노드번호]에 1값을 추가한다.
3. 부모 노드로 올라가게 되면 자식 노드들의 정점의 개수가 합산된다.

## 풀이 코드

```python
import sys
sys.setrecursionlimit(10**8)
# sys.stdin = open('dp/230603_bj_g5_트리와 쿼리/1.in', 'r')
input = sys.stdin.readline

from collections import defaultdict

def solution(n, tree, root, queries):
    dp = defaultdict(int) # query 결과를 임시저장할 dp
    # dp를 저장하기만 하면 쿼리당 시간복잡도는 O(1)이 된다.
    visited = [False] * (n+1)

    def dfs(tree, root):
        if visited[root]:
            return 0
        visited[root] = True
        dp[root] += 1
        for c_node in tree[root]:
            dp[root] += dfs(tree, c_node)
        return dp[root]

    dfs(tree, root)
    answer = []
    for query in queries:
        answer.append(dp[query])
    return answer

N, R, Q = map(int, input().split())

tree = defaultdict(list)
for _ in range(N-1):
    u, v = map(int, input().split())
    tree[u].append(v)
    tree[v].append(u)

queries = [int(input()) for _ in range(Q)]

print(*solution(N, tree, R, queries), sep='\n')
```
