## 문제 링크

[1197번: 최소 스패닝 트리](https://www.acmicpc.net/problem/1197)

## 풀이 과정

- 이 문제는 대표적으로 크루스칼, 프림 알고리즘 두 방식으로 풀 수 있습니다.
- 프림 알고리즘에서 최소 가중치 간선을 찾기 위해서 최소힙을 사용하는 것은 이제 너무 일반적이므로 본 포스트에서는 프림 알고리즘 ElogE, ElogV 두 방식으로 해결한 사례를 설명합니다.
- 인터넷에 퍼진 자료 중 일부는 ElogE 알고리즘을 ElogV라 잘못 설명하는 경우가 있으니 이 포스트를 보고 차이점을 알아가길 바랍니다.
- 저도 예전에 잘못된 정보로 ElogE 알고리즘을 ElogV라 착각하고 해당 복잡도가 실제로 필요한 경우 풀리지 않았던 경험이 있네요.

## 풀이과정 O(ElogE)

1. 프림 알고리즘은 모든 노드를 탐색한 노드와 아닌 노드를 구별하는 것에서 시작한다.
2. 탐색한 노드 T는 처음엔 비어 있다.
3. 탐색할 노드들을 뜻하는 dist라는 가중치 기준 최소힙 노드 리스트를 따로 둔다. dist의 원소는 (가중치, 탐색할 노드)다.
4. 임의의 노드를 dist에 시작점으로 둔다. 이 때 (0, 노드번호)로 넣는다.
5. dist를 탐색하지 않은 노드(visit 조건 활용)를 찾을 때까지 pop하며 가장 가중치가 작은 것을 사용한다.
6. answer를 pop된 가중치만큼 증가시킨다.
7. pop된 노드와 연결된 노드들을 탐색할 노드로 dist에 (가중치, 탐색할 노드)로 삽입한다.
8. dist가 빌 때까지 5~7 과정을 반복한다.

## 풀이 코드

```python
import sys
input = sys.stdin.readline

from collections import defaultdict
from heapq import heappush, heappop

def solution(V, E):
    answer = 0

    graph = defaultdict(list)
    for _ in range(E):
        A, B, C = map(int, input().split())
        graph[A].append((C, B))
        graph[B].append((C, A))

    visited = set()
    dist = [(0, 1)]
    while dist:
        c, d = heappop(dist)
        if d in visited:
            continue
        visited.add(d)
        answer += c
        for c, i in graph[d]:
            heappush(dist, (c, i))
    return answer

V, E = map(int, input().split())

print(solution(V, E))
```

## 풀이과정 O(ElogV)

- 달라지는 것은 노드 개수만큼 heap을 이용하는 것입니다. 탐색할 노드에 도달할 수 있는 최소비용을 heap에 넣습니다.
- 이 로직을 이용해 백준의 문제를 풀기 위해선 직접 heapdict 자료형을 구현해야 합니다.
- 하지만 저작권 문제상 그렇게 할 수 없기에 패키지를 사용하겠습니다.

1. 프림 알고리즘은 모든 노드를 탐색한 노드와 아닌 노드를 구별하는 것에서 시작한다.
2. 탐색한 노드 T는 처음엔 비어 있다.
3. 탐색할 노드들을 뜻하는 dist라는 heapdict 리스트를 따로 둔다. dist의 원소는 (탐색할 노드, 가중치)다.
4. 모든 노드를 dist에 가중치를 inf값으로 넣는다. 그 후 시작 노드의 가중치를 0으로 한다.
5. dist에서 pop한 값을 사용한다
6. answer를 pop된 가중치만큼 증가시킨다.
7. pop된 노드와 연결된 노드들의 가중치가 기존보다 작다 dist의 해당 키의 값을 업데이트 한다.
8. dist가 빌 때까지 5~7 과정을 반복한다.

```python
# pip install HeapDict
from heapdict import heapdict
import sys
# sys.stdin = open("mst/230530_bj_g4_최소 스패닝 트리/1.in", "r")
input = sys.stdin.readline

from collections import defaultdict

def solution(graph):
    answer = 0
    dist = HeapDict({i: float('inf') for i in graph})
    dist[1] = 0

    while dist:
        d, c = dist.popitem()
        answer += c
        for c, i in graph[d]:
            if i in dist and dist[i] > c:
                dist[i] = c
    return answer

V, E = map(int, input().split())
graph = defaultdict(list)
for _ in range(E):
    A, B, C = map(int, input().split())
    graph[A].append((C, B))
    graph[B].append((C, A))

print(solution(graph))
```
